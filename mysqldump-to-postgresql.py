#!/usr/bin/env python

# Copyright (c) 2012 Lanyrd Ltd.
# Copyright (c) 2018 Adeprimo AB
# 
# All rights reserved.
# 
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
# 
# Redistributions of source code must retain the above copyright notice, this
# list of conditions and the following disclaimer.
# 
# Redistributions in binary form must reproduce the above copyright notice, this
# list of conditions and the following disclaimer in the documentation and/or
# other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
# OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

# Based on https://github.com/lanyrd/mysql-postgresql-converter

import argparse
import datetime
import json
import re
import sys

"""
First of all, if possible you should use a better solution
than this script. ``pgloader`` is usually a safe bet. If
you for whatever reason can not do that, then by all means
do read on.

Also notice that this script is somewhat useless unless you
are using an ORM that can takes care of the db structure for
you (for example: Django's ORM, SqlAlchemy or maybe PonyORM),
as this script will only handle data.

You will need Python 3.5+ (any 3.x version could work, but
only 3.5+ has been tested).

The script expects to get a mysqldump file generated by:

    mysqldump \
        --user=root \
        --password=root \
        --add-drop-table=false \
        --add-locks=false \
        --compatible=postgresql \
        --default-character-set=utf8 \
        database_name

Example for the settings format for the ``-s`` flag follows:

    {
        "skip_tables": [
            "django_migrations"
        ],
        "map_tables": {
            "foo": "bar"
        }
    }
"""

slasher = '<{}>'.format(':'.join([
    '1db4c4ab-1871-459f-8481-a61c0e33ed65',
    'c013a1ce-61bc-484c-9620-78f172628ba6',
    '51d2ab81-4a0b-475f-961e-f02b968c8b4d',
    'c2381057-fa01-4f64-a074-01fdb206b978',
]))

def actual_table(args, name):
    return args.settings['map_tables'][name] \
        if 'map_tables' in args.settings and name in args.settings['map_tables'] \
        else name

def collect_inserts(args, lines, tables):
    def fix_rows(rows, table, tables):
        fixed_rows = []
        for row in rows:
            fixed_cols = []
            for val, meta in zip(row, tables[table]):
                if 'tinyint' in meta:
                    fixed_cols.append('true' if val == '1' else 'false')
                else:
                    fixed_cols.append(val)
            fixed_rows.append(fixed_cols)
        return fixed_rows
    print('collect_inserts()', file=sys.stderr)
    i = 0
    n = len(lines)
    inserts = []
    while i < n:
        line = lines[i]
        if line.startswith('INSERT INTO'):
            line = line.replace(r"\\", slasher)
            line = line.replace(r"\'", "''")
            line = line.replace(slasher, r"\\")
            match = re.search(r'^INSERT INTO "(\w+)" VALUES', line)
            if match is None:
                raise ValueError(
                    'could not determine table name for insert at line {}'.format(i)
                )
            table = match.group(1)
            if not table in tables:
                print('skipped INSERT for "{}"'.format(table))
                i = i + 1
                continue
            print('found INSERT for "{}"'.format(table))
            j = line.index('(')
            ch = ''
            cols = []
            rows = []
            while ch != "\n":
                k = j + 1
                ch = line[j]
                # Ignore whitespaces used for readability
                while ch.isspace():
                    j = j + 1
                    ch = line[j]
                if ch == "'":
                    # Scan for end of string
                    while ch != "\n":
                        ch = line[k]
                        k = k + 1
                        if ch == "'":
                            # escaped "'"; "''"?
                            if line[k] == "'":
                                k = k + 1
                            else:
                                break
                    else:
                        raise ValueError(
                            'could not find the end of a string starting at line {}:{}'.format(i, j)
                        )
                    cols.append(line[j:k])
                    j = k
                elif ch == '(':
                    # Opening row
                    j = j + 1
                    continue
                elif ch == ',':
                    # Column or row separator
                    j = j + 1
                    continue
                elif ch == ')':
                    # Closing row
                    rows.append(cols)
                    cols = []
                    if line[j + 1] == ';':
                        break
                    j = line.index('(', j)
                    continue
                else:
                    k = j
                    # Scan for end of value
                    while ch != "\n":
                        k = k + 1
                        ch = line[k]
                        if ch in [',', ')']:
                            break
                    else:
                        raise ValueError(
                            'could not find the end of a value starting at line {}:{}'.format(i, j)
                        )
                    cols.append(line[j:k])
                    j = k
            else:
                # The loop should break when closing the last row
                raise ValueError(
                    'could not find the proper end of the INSERT statement starting at line {}'.format(i)
                )
            rows = fix_rows(rows, table, tables)
            groups = ['({})'.format(', '.join(cols)) for cols in rows]
            inserts.append('INSERT INTO "{}" VALUES {};'.format(
                actual_table(args, table),
                ', '.join(groups))
            )
        i = i + 1
    return inserts

def collect_tables(args, lines):
    def trim_column(column):
        return re.sub(r'\s*,\s*\r?\n$', '', column).strip()
    print('collect_tables()', file=sys.stderr)
    i = 0
    j = 0
    n = len(lines)
    tables = {}
    skipables = args.settings['skip_tables'] \
        if 'skip_tables' in args.settings \
        else []
    while i < n:
        line = lines[i]
        if line.startswith('CREATE TABLE'):
            j = i
            while j < n:
                if lines[j].startswith(');'):
                    break
                j = j + 1
            else:
                raise ValueError(
                    'could not find end of CREATE TABLE starting at line {}'.format(i)
                )
            match = re.search(r'"(\w+)"', lines[i])
            if match is None:
                raise ValueError(
                    'could not find name of CREATE TABLE starting at line {}'.format(i)
                )
            name = match.group(1)
            columns = lines[(i + 1):j]
            i = j
            if name not in skipables:
                print('found table "{}"'.format(name), file=sys.stderr)
                tables[name] = [trim_column(column) for column in columns]
            else:
                print('skipped table "{}"'.format(name), file=sys.stderr)
        i = i + 1
    return tables

def collect_truncations(args, tables):
    return [
        'TRUNCATE {} CASCADE;'.format(
            actual_table(args, table)
        ) for table in sorted(tables.keys())
    ]

def rewrite(args):
    infile = args.infile
    outfile = args.outfile
    with open(infile, 'r') as inf:
        mysql = inf.readlines()
        tables = collect_tables(args, mysql)
        truncations = collect_truncations(args, tables)
        inserts = collect_inserts(args, mysql, tables)
        statments = [
            '-- Generated {}'.format(datetime.datetime.now()),
            'START TRANSACTION;',
            'SET standard_conforming_strings=off;',
            'SET escape_string_warning=off;',
            'SET CONSTRAINTS ALL DEFERRED;',
        ] + truncations + inserts + [
            'COMMIT;',
        ]
        psql = "{}\n".format("\n".join(statments))
        with open(outfile, 'w+') as outf:
            outf.write(psql)

if __name__ == '__main__':
    description = 'Convert a mysqldump SQL file to be PostgreSQL compatible.'
    usage = " ".join([
        sys.argv[0],
        '-i path/to/file.mysql',
        '-o path/to/file.psql',
    ])
    argsparser = argparse.ArgumentParser(
        description=description,
        usage=usage
    )
    argsparser.add_argument(
        '-i',
        '--infile',
        dest='infile',
        required=True,
        metavar='',
        help='path to a mysqldump SQL file'
    )
    argsparser.add_argument(
        '-o',
        '--outfile',
        dest='outfile',
        required=True,
        metavar='',
        help='path to write the PSQL file to'
    )
    argsparser.add_argument(
        '-s',
        '--settings',
        dest='settings',
        required=False,
        metavar='',
        default=None,
        help='path to a JSON settings file'
    )
    args = argsparser.parse_args()
    if args.settings is not None:
        with open(args.settings, 'r') as jsonf:
            args.settings = json.loads(jsonf.read())
    else:
        args.settings = {}
    rewrite(args)

